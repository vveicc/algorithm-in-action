# 位运算

## CF1469E. A Bit Similar

???+ note "问题描述"
    输入 `T(0≤T≤1e4)` 表示 `T` 组数据。所有数据的 `n` 之和 `≤1e6`。<br>
    每组数据第一行输入 `n k(1≤k≤n≤1e6)` 两个整数，第二行输入长为 `n` 的 01 字符串 `s` 。<br>
    定义两个长为 `k` 的字符串 `x` 和 `y` **一点点相同**：存在某个下标 `i` ，使得 `x[i] = y[i]` 。<br>
    你需要找到一个长为 `k` 的字典序最小的 01 串 `t` ，使得 `t` 与 `s` 的每个长为 `k` 的子串都 **一点点相同**。<br>
    如果不存在这样的 `t` ，输出 `NO` ；否则第一行输出 `YES` ，第二行输出 `t` 。

    在 [Codeforces](https://codeforces.com/problemset/problem/1469/E "2400")
    或 [洛谷](https://www.luogu.com.cn/problem/CF1469E "提高+/省选-") 查看该题。

??? info "解题思路"
    定义 `~t` 为 `t` 取反后的字符串。只要 `~t` 不在 `s` 中，`t` 就是合法的答案。<br>
    原因：`s` 的每个长为 `k` 的子串都与 `~t` 至少有一个字符不相同，也即是与 `t` 至少有一个字符相同。

    字符串 `s` 中长为 `k` 的子串有 `n-k+1` 个。<br>
    记 `n-k+1` 的有效二进制长度为 `m`，则长为 `m` 的不同 01 串有超过 `n-k+1` 个。

    将 `t` 分成左右两部分：$t = t_l + t_r$，其中 $t_r$ 的长度为 $r = min(k, m)$ ，则 $t_l$ 的长度为 $l = k - r$ 。<br>
    由于需要找到字典序最小的 `t` ，直接将 $t_l$ 全部置为 `0` 。<br>
    将 `s` 中每个长为 `k` 的子串 `h` 也分成长度分别为 $l$ 和 $r$ 的两部分：$h = h_l + h_r$。<br>
    如果 $h_l$ 全为 1 ，则 ~$t_r$ 不能与 $h_r$ 相同，否则，`s` 包含 `~t` ，`t` 非法。<br>
    统计所有 $h_l$ 全为 1 的 $h_r$ ，即为所有不合法的 ~$t_r$ 。<br>
    由于 `r < 20` ，直接通过整数位运算处理存在的 $h_r$ ，并使用数组记录。<br>
    从大到小枚举，找到第一个不存在的 $h_r$ ，即为字典序最大的合法 ~$t_r$ ，取反即为字典序最小的合法 $t_r$ 。

    === "Go"
        ```go
        --8<-- "bit/go/cf1469e.go"
        ```
    === "Java"
        ```java
        --8<-- "bit/java/cf1469e/Main.java"
        ```
